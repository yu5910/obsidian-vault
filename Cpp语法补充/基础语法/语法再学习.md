l a）布尔型变量的值在计算机内部用1（true）和0（false）存储；b）程序中可以书写 true 和 false，也可以书写1和0，其它值将强制转换成1；c）用 cin 输入时可以填1和0，其它值也强制转换成1；d）用 cout 输出时只显示1和0，不显示 true 和 false。
![[Pasted image 20231109002432.png|475]]
![[Pasted image 20231109002546.png|425]]
![[Pasted image 20231109003353.png|425]]
l **不要把****i****f****（变量名=****=****值）****写成****i****f****（变量名****=****值）****。**
l if 或 else 分支花括号内的代码如果只有一行，花括号可以不写；
![[Pasted image 20231109004006.png|500]]
![[Pasted image 20231109004134.png|450]]
![[Pasted image 20231109004424.png]]
![[Pasted image 20231109004541.png]]
l 函数的声明和定义可以书写在一起，也可以分开，如果书写在一起，一般放在 main 函数的上面，如果分开，一般在 main 函数的上面声明，在 main 函数的下面定义。
l 如果函数的声明和定义分开书写，函数的声明后面一定要有分号，函数的定义后面一定不能写分号。
l // 这是函数声明
l int add(int a, int b);  // 分号结束
![[Pasted image 20231109004752.png|450]]
l 在同一个程序中，函数只需要声明和定义一次，也可以多次声明，但只能定义一次。
l 函数的声明必须和函数的定义一致（返回值的数据类型、函数名和参数列表），如果函数名和参数列表不同，表示它们不是同一个函数。
![[Pasted image 20231109005148.png]]
调用函数的时候，参数列表必须与函数的声明一致（参数的个数、书写的顺序和数据类型）
全局变量在主程序退出时由系统收回内存空间。
局部变量在函数返回或语句块结束时由系统收回内存空间。
## **静态局部变量**

用static修饰的局部变量生命周期和程序相同，并且只会被初始化一次。

其作用域为局部，当定义它的函数或语句块结束时，其作用域随之结束。
全局变量和静态局部变量自动初始化为0
l 局部变量不会自动初始化，其值是不确定的，程序中应该有初始化局部变量的代码，否则编译可能会报错（不同的编译器不一样）。

局部变量和全局变量的名称可以相同，在某函数或语句块内部，如果局部变量名与全局变量名相同，就会屏蔽全局变量而使用局部变量，如果想使用全局变量，可以在变量名前加两个冒号（::）
# **函数分文件编写**

**头文件（*****.h****）**：需要包含的头文件，声明全局变量，函数的声明，数据结构和类的声明等。

**源文件（*****.cpp****）**：函数的定义、类的定义。

主程序：main 函数，程序的核心流程，需要用 #include "头文件名"把头文件包含进来。
![[Pasted image 20231109010116.png|400]]
在声明整型变量的时候，可以在 int 关键字之前加 signed、unsigned、short 和 long 四种修饰符。
![[Pasted image 20231109010224.png]]
![[Pasted image 20231109010341.png]]
八进制由 0~7 八个数字组成，书写时必须以0开头（注意是数字 0，不是字母 o）。
![[Pasted image 20231109010425.png]]
**在 C****++****中，不要在十进制数前面加0，会被编译器当成八进制。**
**还有，不要随便删掉别人程序中整数前面的0，它不是多余的。*
*
![[Pasted image 20231109010543.png|425]]
int a = 'X'; `
![[Pasted image 20231109010810.png|425]]
![[Pasted image 20231109010930.png]]
![[Pasted image 20231109011005.png|475]] 
![[Pasted image 20231109011143.png]]
用cin输入和cout输出的时候，仍是1和0，不会被解释为true和false。
![[Pasted image 20231109011318.png|375]]
![[Pasted image 20231109011448.png|425]]
![[Pasted image 20231109011752.png|450]]
在64位的操作系统中，不管是什么类型的指针，占用的内存都是8字节。
语法：const 数据类型 *变量名;
不能通过解引用的方法修改内存地址中的值（用原始的变量名是可以修改的）。
l 如果形参的值不需要改变，建议加上 const 修饰，程序可读性更好。
![[Pasted image 20231109012502.png|500]]
常量指针：指针指向可以改，指针指向的值不可以更改。

指针常量：指针指向不可以改，指针指向的值可以更改。

常指针常量：指针指向不可以改，指针指向的值不可以更改。
![[Pasted image 20231109012735.png|375]]
![[Pasted image 20231109012900.png|225]]
![[Pasted image 20231109013001.png|425]]
申请内存的语法：new 数据类型(初始值);   // C++11支持{}
释放内存的语法：delete 地址;
在 C 和 C++中，用0或 NULL 都可以表示空指针。

声明指针后，在赋值之前，让它指向空，表示没有指向任何地址。
用0和 NULL 表示空指针会产生歧义，C++11建议用 nullptr 表示空指针，也就是(void \*)0
![[Pasted image 20231109013547.png]]
![[Pasted image 20231109013624.png]]
则函数指针的声明是：

int  (\*pfa)(int,string);
pfa是函数指针名，必须用括号，否则就成了返回指针的函数。
函数指针名=函数名;
![[Pasted image 20231109013952.png|450]]
![[Pasted image 20231109014047.png|400]]
用 memcpy()函数可以把数组中全部的元素复制到另一个相同大小的数组
![[Pasted image 20231109014222.png]]
C++编译器把数组名[下标]  **解释为**  *(数组首地址+下标)
在多数情况下，C++将数组名解释为数组的第0个元素的地址，但是，将 sizeof 运算符用于数据名时，将返回整个数组占用内存空间的字节数。
![[Pasted image 20231109014522.png|336]]
![[Pasted image 20231109014615.png]]
动态创建一维数组的语法：数据类型 *指针=new 数据类型[数组长度];
释放一维数组的语法：delete [] 指针;
![[Pasted image 20231109014837.png|450]]
###  [[C++字符串]]
不能在子函数中对传入的字符串进行初始化，除非字符串的长度也作为参数传入到了子函数中。
）**字符串在每次使用前都要初始化**，减少入坑的可能，**是每次，不是第一次**。
）结尾标志0后面的都是垃圾内容。
![[Pasted image 20231109015732.png|500]]
![[Pasted image 20231109020009.png|450]]
l 结构体成员可以用 C++的类（如 string），但是不提倡。
l 在C++中，结构体中可以有函数，但是不提倡。
l 在 C++11中，定义结构体的时候可以指定缺省值。
![[Pasted image 20231109020147.png|450]]
用 memset()函数可以把结构体中全部的成员清零。（只适用于 C++基本数据类型）
    st_girl stgirl{"西施",26,33.8,'X',true};        // 创建结构体变量。
    
    ![[Pasted image 20231109020452.png|500]]
![[Pasted image 20231109020600.png]]
![[Pasted image 20231109020923.png|450]]
![[Pasted image 20231109021241.png]]
![[Pasted image 20231109021301.png|375]]
![[Pasted image 20231109021315.png|475]]
引用的主要用途是用作函数的形参和返回值。
l 必须在声明引用的时候初始化，初始化后不可改变。
引用的底层机制实际上是和指针一样的。不要相信有别名，不要认为引用可以节省一个指针的空间，因为这一切不会发生，编译器还是会把引用解释为指针。
引用和指针本质上没有区别。
![[Pasted image 20231109021602.png]]
2）传引用不必使用二级指针。
![[Pasted image 20231109035557.png|475]]
![[Pasted image 20231109041355.png]]
Const 可以解决右值的问题
![[Pasted image 20231109042519.png|425]]
![[Pasted image 20231109042823.png|450]]
![[Pasted image 20231109042859.png]]
因为字符串常量有地址
编译器会在编译时将字符串常量转换为字符串对象，并将其存储在程序的数据段中。
![[Pasted image 20231109043922.png]]
![[Pasted image 20231109044256.png|425]]
![[Pasted image 20231109045443.png|475]]
![[Pasted image 20231109045738.png|600]]
